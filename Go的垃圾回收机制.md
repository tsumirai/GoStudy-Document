# Go的垃圾回收器
go语言垃圾回收总体采用的是经典的mark and sweep算法。  
* 1.3版本之前，golang的垃圾回收算法都非常简陋，然后其性能也被广为诟病：go runtime在一定条件下（内存超过阈值或定期如2min），暂停所有任务的执行，进行mark&sweep操作，操作完成后启动所有任务的执行。在内存使用较多的场景下，go程序在进行垃圾回收时会发生非常明显的卡顿现象（Stop The World）。在对响应速度要求较高的后台服务进程中，这种延迟简直是不能忍受的。当时解决这个问题比较常用的方法是尽快控制自动分配内存的内存数量，以减少gc负荷，同时采用手动管理内存的方法处理需要大量及高频分配内存的场景。
  
* 1.3版本开始go team开始对gc性能进行持续的改进和优化，1.3版本中，go runtime分离了mark和sweep操作，和以前一样，也是先暂停所有任务执行并启动mark，mark完成后马上就重新启动被暂停的任务，让sweep任务和普通协程任务一样并行地一起执行。如果运行在多核处理器上，go会试图将gc任务放到单独的核心上运行而尽量不影响业务代码的执行。go team自己的说法是减少了50%-70%的暂停时间。
  
* 1.4版本对gc的性能改动并不多。1.4版本中runtime很多代码取代了原生c语言实现而采用了go语言实现。对gc带来的一大改变是可以实现精确的gc。c语言实现在gc时无法获取到内存的对象信息，因此无法准确区分普通变量和指针，只能将普通变量当做指针，如果碰巧这个普通变量指向的空间有其他对象，那这个对象就不会被回收。而go语言实现是完全知道对象的类型信息，在标记时只会遍历指针指向的对象，这样就避免了c实现时的堆内存浪费（解决约10-30%）。
  
* 1.5版本go team对gc又进行了比较大的改进。官方的主要目标是减少延迟。go 1.5正在实现的垃圾回收器是“非分代的、非移动的、并发的、三色的标记清除垃圾回收器”。这种方法的mark操作时可以渐进执行的而不需要每次都扫描整个内存空间，可以减少stop the world的时间。